[33mcommit 925445af826a808b472cfad6708c394c4cf430c7[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;33mtag: part3[m[33m, [m[1;31morigin/master[m[33m, [m[1;31morigin/HEAD[m[33m)[m
Author: Juha Jeon <jeon66@data.cs.purdue.edu>
Date:   Sun Oct 31 23:22:19 2021 -0400

    \Total:                   63.0 of 70.0\

[1mdiff --git a/lex.yy.cc b/lex.yy.cc[m
[1mdeleted file mode 100644[m
[1mindex 4af7a6f..0000000[m
[1m--- a/lex.yy.cc[m
[1m+++ /dev/null[m
[36m@@ -1,2229 +0,0 @@[m
[31m-#line 2 "lex.yy.cc"[m
[31m-[m
[31m-#line 4 "lex.yy.cc"[m
[31m-[m
[31m-#define  YY_INT_ALIGNED short int[m
[31m-[m
[31m-/* A lexical scanner generated by flex */[m
[31m-[m
[31m-#define FLEX_SCANNER[m
[31m-#define YY_FLEX_MAJOR_VERSION 2[m
[31m-#define YY_FLEX_MINOR_VERSION 6[m
[31m-#define YY_FLEX_SUBMINOR_VERSION 4[m
[31m-#if YY_FLEX_SUBMINOR_VERSION > 0[m
[31m-#define FLEX_BETA[m
[31m-#endif[m
[31m-[m
[31m-/* First, we deal with  platform-specific or compiler-specific issues. */[m
[31m-[m
[31m-/* begin standard C headers. */[m
[31m-#include <stdio.h>[m
[31m-#include <string.h>[m
[31m-#include <errno.h>[m
[31m-#include <stdlib.h>[m
[31m-[m
[31m-/* end standard C headers. */[m
[31m-[m
[31m-/* flex integer type definitions */[m
[31m-[m
[31m-#ifndef FLEXINT_H[m
[31m-#define FLEXINT_H[m
[31m-[m
[31m-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */[m
[31m-[m
[31m-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L[m
[31m-[m
[31m-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,[m
[31m- * if you want the limit (max/min) macros for int types. [m
[31m- */[m
[31m-#ifndef __STDC_LIMIT_MACROS[m
[31m-#define __STDC_LIMIT_MACROS 1[m
[31m-#endif[m
[31m-[m
[31m-#include <inttypes.h>[m
[31m-typedef int8_t flex_int8_t;[m
[31m-typedef uint8_t flex_uint8_t;[m
[31m-typedef int16_t flex_int16_t;[m
[31m-typedef uint16_t flex_uint16_t;[m
[31m-typedef int32_t flex_int32_t;[m
[31m-typedef uint32_t flex_uint32_t;[m
[31m-#else[m
[31m-typedef signed char flex_int8_t;[m
[31m-typedef short int flex_int16_t;[m
[31m-typedef int flex_int32_t;[m
[31m-typedef unsigned char flex_uint8_t; [m
[31m-typedef unsigned short int flex_uint16_t;[m
[31m-typedef unsigned int flex_uint32_t;[m
[31m-[m
[31m-/* Limits of integral types. */[m
[31m-#ifndef INT8_MIN[m
[31m-#define INT8_MIN               (-128)[m
[31m-#endif[m
[31m-#ifndef INT16_MIN[m
[31m-#define INT16_MIN              (-32767-1)[m
[31m-#endif[m
[31m-#ifndef INT32_MIN[m
[31m-#define INT32_MIN              (-2147483647-1)[m
[31m-#endif[m
[31m-#ifndef INT8_MAX[m
[31m-#define INT8_MAX               (127)[m
[31m-#endif[m
[31m-#ifndef INT16_MAX[m
[31m-#define INT16_MAX              (32767)[m
[31m-#endif[m
[31m-#ifndef INT32_MAX[m
[31m-#define INT32_MAX              (2147483647)[m
[31m-#endif[m
[31m-#ifndef UINT8_MAX[m
[31m-#define UINT8_MAX              (255U)[m
[31m-#endif[m
[31m-#ifndef UINT16_MAX[m
[31m-#define UINT16_MAX             (65535U)[m
[31m-#endif[m
[31m-#ifndef UINT32_MAX[m
[31m-#define UINT32_MAX             (4294967295U)[m
[31m-#endif[m
[31m-[m
[31m-#ifndef SIZE_MAX[m
[31m-#define SIZE_MAX               (~(size_t)0)[m
[31m-#endif[m
[31m-[m
[31m-#endif /* ! C99 */[m
[31m-[m
[31m-#endif /* ! FLEXINT_H */[m
[31m-[m
[31m-/* begin standard C++ headers. */[m
[31m-[m
[31m-/* TODO: this is always defined, so inline it */[m
[31m-#define yyconst const[m
[31m-[m
[31m-#if defined(__GNUC__) && __GNUC__ >= 3[m
[31m-#define yynoreturn __attribute__((__noreturn__))[m
[31m-#else[m
[31m-#define yynoreturn[m
[31m-#endif[m
[31m-[m
[31m-/* Returned upon end-of-file. */[m
[31m-#define YY_NULL 0[m
[31m-[m
[31m-/* Promotes a possibly negative, possibly signed char to an[m
[31m- *   integer in range [0..255] for use as an array index.[m
[31m- */[m
[31m-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))[m
[31m-[m
[31m-/* Enter a start condition.  This macro really ought to take a parameter,[m
[31m- * but we do it the disgusting crufty way forced on us by the ()-less[m
[31m- * definition of BEGIN.[m
[31m- */[m
[31m-#define BEGIN (yy_start) = 1 + 2 *[m
[31m-/* Translate the current start state into a value that can be later handed[m
[31m- * to BEGIN to return to the state.  The YYSTATE alias is for lex[m
[31m- * compatibility.[m
[31m- */[m
[31m-#define YY_START (((yy_start) - 1) / 2)[m
[31m-#define YYSTATE YY_START[m
[31m-/* Action number for EOF rule of a given start state. */[m
[31m-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)[m
[31m-/* Special action meaning "start processing a new file". */[m
[31m-#define YY_NEW_FILE yyrestart( yyin  )[m
[31m-#define YY_END_OF_BUFFER_CHAR 0[m
[31m-[m
[31m-/* Size of default input buffer. */[m
[31m-#ifndef YY_BUF_SIZE[m
[31m-#ifdef __ia64__[m
[31m-/* On IA-64, the buffer size is 16k, not 8k.[m
[31m- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.[m
[31m- * Ditto for the __ia64__ case accordingly.[m
[31m- */[m
[31m-#define YY_BUF_SIZE 32768[m
[31m-#else[m
[31m-#define YY_BUF_SIZE 16384[m
[31m-#endif /* __ia64__ */[m
[31m-#endif[m
[31m-[m
[31m-/* The state buf must be large enough to hold one state per character in the main buffer.[m
[31m- */[m
[31m-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))[m
[31m-[m
[31m-#ifndef YY_TYPEDEF_YY_BUFFER_STATE[m
[31m-#define YY_TYPEDEF_YY_BUFFER_STATE[m
[31m-typedef struct yy_buffer_state *YY_BUFFER_STATE;[m
[31m-#endif[m
[31m-[m
[31m-#ifndef YY_TYPEDEF_YY_SIZE_T[m
[31m-#define YY_TYPEDEF_YY_SIZE_T[m
[31m-typedef size_t yy_size_t;[m
[31m-#endif[m
[31m-[m
[31m-extern int yyleng;[m
[31m-[m
[31m-extern FILE *yyin, *yyout;[m
[31m-[m
[31m-#define EOB_ACT_CONTINUE_SCAN 0[m
[31m-#define EOB_ACT_END_OF_FILE 1[m
[31m-#define EOB_ACT_LAST_MATCH 2[m
[31m-    [m
[31m-    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires[m
[31m-     *       access to the local variable yy_act. Since yyless() is a macro, it would break[m
[31m-     *       existing scanners that call yyless() from OUTSIDE yylex.[m
[31m-     *       One obvious solution it to make yy_act a global. I tried that, and saw[m
[31m-     *       a 5% performance hit in a non-yylineno scanner, because yy_act is[m
[31m-     *       normally declared as a register variable-- so it is not worth it.[m
[31m-     */[m
[31m-    #define  YY_LESS_LINENO(n) \[m
[31m-            do { \[m
[31m-                int yyl;\[m
[31m-                for ( yyl = n; yyl < yyleng; ++yyl )\[m
[31m-                    if ( yytext[yyl] == '\n' )\[m
[31m-                        --yylineno;\[m
[31m-            }while(0)[m
[31m-    #define YY_LINENO_REWIND_TO(dst) \[m
[31m-            do {\[m
[31m-                const char *p;\[m
[31m-                for ( p = yy_cp-1; p >= (dst); --p)\[m
[31m-                    if ( *p == '\n' )\[m
[31m-                        --yylineno;\[m
[31m-            }while(0)[m
[31m-    [m
[31m-/* Return all but the first "n" matched characters back to the input stream. */[m
[31m-#define yyless(n) \[m
[31m-	do \[m
[31m-		{ \[m
[31m-		/* Undo effects of setting up yytext. */ \[m
[31m-        int yyless_macro_arg = (n); \[m
[31m-        YY_LESS_LINENO(yyless_macro_arg);\[m
[31m-		*yy_cp = (yy_hold_char); \[m
[31m-		YY_RESTORE_YY_MORE_OFFSET \[m
[31m-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \[m
[31m-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \[m
[31m-		} \[m
[31m-	while ( 0 )[m
[31m-#define unput(c) yyunput( c, (yytext_ptr)  )[m
[31m-[m
[31m-#ifndef YY_STRUCT_YY_BUFFER_STATE[m
[31m-#define YY_STRUCT_YY_BUFFER_STATE[m
[31m-struct yy_buffer_state[m
[31m-	{[m
[31m-	FILE *yy_input_file;[m
[31m-[m
[31m-	char *yy_ch_buf;		/* input buffer */[m
[31m-	char *yy_buf_pos;		/* current position in input buffer */[m
[31m-[m
[31m-	/* Size of input buffer in bytes, not including room for EOB[m
[31m-	 * characters.[m
[31m-	 */[m
[31m-	int yy_buf_size;[m
[31m-[m
[31m-	/* Number of characters read into yy_ch_buf, not including EOB[m
[31m-	 * characters.[m
[31m-	 */[m
[31m-	int yy_n_chars;[m
[31m-[m
[31m-	/* Whether we "own" the buffer - i.e., we know we created it,[m
[31m-	 * and can realloc() it to grow it, and should free() it to[m
[31m-	 * delete it.[m
[31m-	 */[m
[31m-	int yy_is_our_buffer;[m
[31m-[m
[31m-	/* Whether this is an "interactive" input source; if so, and[m
[31m-	 * if we're using stdio for input, then we want to use getc()[m
[31m-	 * instead of fread(), to make sure we stop fetching input after[m
[31m-	 * each newline.[m
[31m-	 */[m
[31m-	int yy_is_interactive;[m
[31m-[m
[31m-	/* Whether we're considered to be at the beginning of a line.[m
[31m-	 * If so, '^' rules will be active on the next match, otherwise[m
[31m-	 * not.[m
[31m-	 */[m
[31m-	int yy_at_bol;[m
[31m-[m
[31m-    int yy_bs_lineno; /**< The line count. */[m
[31m-    int yy_bs_column; /**< The column count. */[m
[31m-[m
[31m-	/* Whether to try to fill the input buffer when we reach the[m
[31m-	 * end of it.[m
[31m-	 */[m
[31m-	int yy_fill_buffer;[m
[31m-[m
[31m-	int yy_buffer_status;[m
[31m-[m
[31m-#define YY_BUFFER_NEW 0[m
[31m-#define YY_BUFFER_NORMAL 1[m
[31m-	/* When an EOF's been seen but there's still some text to process[m
[31m-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we[m
[31m-	 * shouldn't try reading from the input source any more.  We might[m
[31m-	 * still have a bunch of tokens to match, though, because of[m
[31m-	 * possible backing-up.[m
[31m-	 *[m
[31m-	 * When we actually see the EOF, we change the status to "new"[m
[31m-	 * (via yyrestart()), so that the user can continue scanning by[m
[31m-	 * just pointing yyin at a new input file.[m
[31m-	 */[m
[31m-#define YY_BUFFER_EOF_PENDING 2[m
[31m-[m
[31m-	};[m
[31m-#endif /* !YY_STRUCT_YY_BUFFER_STATE */[m
[31m-[m
[31m-/* Stack of input buffers. */[m
[31m-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */[m
[31m-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */[m
[31m-static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */[m
[31m-[m
[31m-/* We provide macros for accessing buffer states in case in the[m
[31m- * future we want to put the buffer states in a more general[m
[31m- * "scanner state".[m
[31m- *[m
[31m- * Returns the top of the stack, or NULL.[m
[31m- */[m
[31m-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \[m
[31m-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \[m
[31m-                          : NULL)[m
[31m-/* Same as previous macro, but useful when we know that the buffer stack is not[m
[31m- * NULL or when we need an lvalue. For internal use only.[m
[31m- */[m
[31m-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)][m
[31m-[m
[31m-/* yy_hold_char holds the character lost when yytext is formed. */[m
[31m-static char yy_hold_char;[m
[31m-static int yy_n_chars;		/* number of characters read into yy_ch_buf */[m
[31m-int yyleng;[m
[31m-[m
[31m-/* Points to current character in buffer. */[m
[31m-static char *yy_c_buf_p = NULL;[m
[31m-static int yy_init = 0;		/* whether we need to initialize */[m
[31m-static int yy_start = 0;	/* start state number */[m
[31m-[m
[31m-/* Flag which is used to allow yywrap()'s to do buffer switches[m
[31m- * instead of setting up a fresh yyin.  A bit of a hack ...[m
[31m- */[m
[31m-static int yy_did_buffer_switch_on_eof;[m
[31m-[m
[31m-void yyrestart ( FILE *input_file  );[m
[31m-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );[m
[31m-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );[m
[31m-void yy_delete_buffer ( YY_BUFFER_STATE b  );[m
[31m-void yy_flush_buffer ( YY_BUFFER_STATE b  );[m
[31m-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );[m
[31m-void yypop_buffer_state ( void );[m
[31m-[m
[31m-static void yyensure_buffer_stack ( void );[m
[31m-static void yy_load_buffer_state ( void );[m
[31m-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );[m
[31m-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )[m
[31m-[m
[31m-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );[m
[31m-YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );[m
[31m-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );[m
[31m-[m
[31m-void *yyalloc ( yy_size_t  );[m
[31m-void *yyrealloc ( void *, yy_size_t  );[m
[31m-void yyfree ( void *  );[m
[31m-[m
[31m-#define yy_new_buffer yy_create_buffer[m
[31m-#define yy_set_interactive(is_interactive) \[m
[31m-	{ \[m
[31m-	if ( ! YY_CURRENT_BUFFER ){ \[m
[31m-        yyensure_buffer_stack (); \[m
[31m-		YY_CURRENT_BUFFER_LVALUE =    \[m
[31m-            yy_create_buffer( yyin, YY_BUF_SIZE ); \[m
[31m-	} \[m
[31m-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \[m
[31m-	}[m
[31m-#define yy_set_bol(at_bol) \[m
[31m-	{ \[m
[31m-	if ( ! YY_CURRENT_BUFFER ){\[m
[31m-        yyensure_buffer_stack (); \[m
[31m-		YY_CURRENT_BUFFER_LVALUE =    \[m
[31m-            yy_create_buffer( yyin, YY_BUF_SIZE ); \[m
[31m-	} \[m
[31m-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \[m
[31m-	}[m
[31m-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)[m
[31m-[m
[31m-#define yywrap() (/*CONSTCOND*/1)[m
[31m-#define YY_SKIP_YYWRAP[m
[31m-typedef flex_uint8_t YY_CHAR;[m
[31m-[m
[31m-FILE *yyin = NULL, *yyout = NULL;[m
[31m-[m
[31m-typedef int yy_state_type;[m
[31m-[m
[31m-#define YY_FLEX_LEX_COMPAT[m
[31m-extern int yylineno;[m
[31m-int yylineno = 1;[m
[31m-[m
[31m-extern char yytext[];[m
[31m-[m
[31m-static yy_state_type yy_get_previous_state ( void );[m
[31m-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );[m
[31m-static int yy_get_next_buffer ( void );[m
[31m-static void yynoreturn yy_fatal_error ( const char* msg  );[m
[31m-[m
[31m-/* Done after the current pattern has been matched and before the[m
[31m- * corresponding action - sets up yytext.[m
[31m- */[m
[31m-#define YY_DO_BEFORE_ACTION \[m
[31m-	(yytext_ptr) = yy_bp; \[m
[31m-	yyleng = (int) (yy_cp - yy_bp); \[m
[31m-	(yy_hold_char) = *yy_cp; \[m
[31m-	*yy_cp = '\0'; \[m
[31m-	if ( yyleng >= YYLMAX ) \[m
[31m-		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \[m
[31m-	yy_flex_strncpy( yytext, (yytext_ptr), yyleng + 1 ); \[m
[31m-	(yy_c_buf_p) = yy_cp;[m
[31m-#define YY_NUM_RULES 19[m
[31m-#define YY_END_OF_BUFFER 20[m
[31m-/* This struct is not used in this scanner,[m
[31m-   but its presence is necessary. */[m
[31m-struct yy_trans_info[m
[31m-	{[m
[31m-	flex_int32_t yy_verify;[m
[31m-	flex_int32_t yy_nxt;[m
[31m-	};[m
[31m-static const flex_int16_t yy_accept[86] =[m
[31m-    {   0,[m
[31m-        0,    0,    0,    0,   20,   18,    2,    1,   18,   18,[m
[31m-        9,   18,    8,    7,   17,   18,   18,   10,   12,   14,[m
[31m-       19,   18,   18,   17,   18,    0,   11,   18,   17,   18,[m
[31m-       18,   18,    5,    4,    6,   17,   17,   17,   18,    0,[m
[31m-       18,   17,   16,   18,   12,   12,   12,   14,   11,   11,[m
[31m-       17,   11,   17,   17,   18,    0,   18,   16,   17,   18,[m
[31m-        3,   16,   16,   17,   17,   17,   16,   18,   12,   12,[m
[31m-       12,   11,   16,   16,   17,   17,   16,   17,   15,   16,[m
[31m-       18,   16,   18,   13,    0[m
[31m-    } ;[m
[31m-[m
[31m-static const YY_CHAR yy_ec[256] =[m
[31m-    {   0,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    2,    1,    4,    1,    5,    1,    6,    1,    7,[m
[31m-        8,    1,    1,    1,    1,    1,    1,    1,    1,    9,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,   10,[m
[31m-        1,   11,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,   12,    1,    1,    1,   13,   14,   14,   15,   14,[m
[31m-[m
[31m-       16,   14,   14,   14,   14,   14,   14,   14,   14,   14,[m
[31m-       17,   14,   14,   18,   19,   14,   20,   14,   14,   14,[m
[31m-       14,   14,   21,   22,   23,   24,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1[m
[31m-    } ;[m
[31m-[m
[31m-static const YY_CHAR yy_meta[25] =[m
[31m-    {   0,[m
[31m-        1,    2,    3,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1[m
[31m-    } ;[m
[31m-[m
[31m-static const flex_int16_t yy_base[111] =[m
[31m-    {   0,[m
[31m-        0,    0,   23,   25,  104,   23,  569,  569,   44,   62,[m
[31m-        0,   80,    0,   25,   96,  117,  135,    0,  151,    0,[m
[31m-      569,   32,    0,  168,  189,   99,   36,   28,  210,   93,[m
[31m-      231,  249,    0,    0,   93,    0,    0,    0,  268,   85,[m
[31m-       36,  289,   37,  307,  323,    0,  340,    0,  569,    0,[m
[31m-      361,    0,   57,    0,  382,   89,   62,    0,  403,   39,[m
[31m-        0,  569,    0,  424,   38,    0,    0,  442,  458,    0,[m
[31m-        0,    0,   88,   63,  479,   73,    0,    0,   71,    0,[m
[31m-      497,   78,  514,   72,  569,  535,   94,  538,   93,   89,[m
[31m-      540,   88,   87,  542,  544,  546,  548,   81,  550,  552,[m
[31m-[m
[31m-      554,   62,   51,  556,  558,  560,  562,  564,   46,  566[m
[31m-    } ;[m
[31m-[m
[31m-static const flex_int16_t yy_def[111] =[m
[31m-    {   0,[m
[31m-       85,    1,   86,   86,   85,   87,   85,   85,   88,   87,[m
[31m-       89,   10,   89,   89,   90,   91,   10,   89,   92,   93,[m
[31m-       85,   10,   89,   90,   88,   94,   10,   95,   96,   10,[m
[31m-       97,   10,   89,   89,   89,   24,   98,   24,   91,   99,[m
[31m-      100,  101,   10,   10,   92,  102,  103,   93,   85,   89,[m
[31m-       96,   24,  104,   51,   97,  105,  106,   55,  107,   32,[m
[31m-       89,   85,   89,  101,  108,   64,   24,   10,  103,  109,[m
[31m-       69,   98,  105,  106,  107,  110,   75,   75,   10,   98,[m
[31m-       10,  110,   10,   10,    0,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85[m
[31m-    } ;[m
[31m-[m
[31m-static const flex_int16_t yy_nxt[594] =[m
[31m-    {   0,[m
[31m-        6,    7,    8,    9,   10,   11,    6,    6,   12,   13,[m
[31m-       14,   15,   16,    6,    6,    6,    6,    6,   17,    6,[m
[31m-        6,   18,    6,   19,   21,   21,   21,   21,   23,   26,[m
[31m-       34,   50,   23,   23,   24,   35,   22,   40,   22,   40,[m
[31m-       22,   22,   22,   22,   23,   26,   70,   27,   63,   28,[m
[31m-       80,   69,   22,   28,   28,   29,   22,   22,   26,   22,[m
[31m-       72,   79,   46,   56,   56,   28,   30,   23,   31,   74,[m
[31m-       74,   23,   23,   24,   56,   22,   22,   22,   22,   56,[m
[31m-       82,   37,   32,   23,   22,   82,   22,   48,   45,   36,[m
[31m-       33,   22,   22,   23,   22,   73,   73,   62,   61,   22,[m
[31m-[m
[31m-       22,   37,   49,   85,   85,   37,   37,   38,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   37,   40,   85,[m
[31m-       85,   85,   41,   85,   85,   85,   41,   41,   42,   43,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   41,   22,[m
[31m-       85,   22,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   44,   85,   85,   85,   22,   46,   85,   85,   85,[m
[31m-       46,   46,   47,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   46,   37,   85,   85,   85,   37,   37,   38,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   37,[m
[31m-       26,   85,   27,   85,   28,   85,   85,   85,   28,   28,[m
[31m-[m
[31m-       29,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       28,   26,   85,   52,   85,   53,   85,   85,   85,   53,[m
[31m-       53,   54,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   53,   56,   85,   85,   85,   57,   85,   58,   85,[m
[31m-       57,   57,   59,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   57,   22,   85,   22,   85,   85,   85,   85,[m
[31m-       85,   85,   60,   60,   60,   60,   60,   60,   60,   40,[m
[31m-       85,   85,   85,   41,   85,   85,   85,   41,   41,   42,[m
[31m-       43,   85,   85,   85,   85,   85,   85,   85,   85,   41,[m
[31m-       40,   85,   85,   85,   65,   85,   85,   85,   65,   65,[m
[31m-[m
[31m-       66,   67,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       65,   22,   85,   22,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   68,   22,   46,   85,[m
[31m-       85,   85,   46,   46,   47,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   46,   70,   85,   85,   85,   70,[m
[31m-       70,   71,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   70,   26,   85,   52,   85,   53,   85,   85,   85,[m
[31m-       53,   53,   54,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   53,   56,   85,   85,   85,   57,   85,   58,[m
[31m-       85,   57,   57,   59,   85,   85,   85,   85,   85,   85,[m
[31m-[m
[31m-       85,   85,   85,   57,   56,   85,   85,   85,   76,   85,[m
[31m-       77,   85,   76,   76,   78,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   76,   40,   85,   85,   85,   65,[m
[31m-       85,   85,   85,   65,   65,   66,   67,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   65,   22,   85,   22,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   81,[m
[31m-       85,   85,   22,   70,   85,   85,   85,   70,   70,   71,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   70,[m
[31m-       56,   85,   85,   85,   76,   85,   77,   85,   76,   76,[m
[31m-       78,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-[m
[31m-       76,   22,   85,   22,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   83,   85,   85,   85,   85,   85,   22,   22,   85,[m
[31m-       22,   85,   85,   85,   85,   85,   85,   85,   85,   84,[m
[31m-       85,   85,   85,   85,   22,   20,   20,   20,   25,   25,[m
[31m-       39,   39,   26,   26,   28,   28,   51,   51,   55,   55,[m
[31m-       40,   40,   41,   41,   64,   64,   53,   53,   56,   56,[m
[31m-       57,   57,   75,   75,   65,   65,   76,   76,    5,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85[m
[31m-[m
[31m-    } ;[m
[31m-[m
[31m-static const flex_int16_t yy_chk[594] =[m
[31m-    {   0,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,[m
[31m-        1,    1,    1,    1,    3,    3,    4,    4,    6,   28,[m
[31m-       14,   28,    6,    6,    6,   14,   22,   41,   22,   65,[m
[31m-       27,   43,   27,   43,    6,    9,  109,    9,   41,    9,[m
[31m-       65,  103,   22,    9,    9,    9,   27,   43,   53,   60,[m
[31m-       53,   60,  102,   57,   74,    9,   10,   10,   10,   57,[m
[31m-       74,   10,   10,   10,   76,   79,   84,   79,   84,   82,[m
[31m-       76,   98,   10,   10,   12,   82,   12,   93,   92,   90,[m
[31m-       12,   79,   84,   89,   87,   73,   56,   40,   35,   30,[m
[31m-[m
[31m-       12,   15,   26,    5,    0,   15,   15,   15,    0,    0,[m
[31m-        0,    0,    0,    0,    0,    0,    0,   15,   16,    0,[m
[31m-        0,    0,   16,    0,    0,    0,   16,   16,   16,   16,[m
[31m-        0,    0,    0,    0,    0,    0,    0,    0,   16,   17,[m
[31m-        0,   17,    0,    0,    0,    0,    0,    0,    0,    0,[m
[31m-        0,   17,    0,    0,    0,   17,   19,    0,    0,    0,[m
[31m-       19,   19,   19,    0,    0,    0,    0,    0,    0,    0,[m
[31m-        0,    0,   19,   24,    0,    0,    0,   24,   24,   24,[m
[31m-        0,    0,    0,    0,    0,    0,    0,    0,    0,   24,[m
[31m-       25,    0,   25,    0,   25,    0,    0,    0,   25,   25,[m
[31m-[m
[31m-       25,    0,    0,    0,    0,    0,    0,    0,    0,    0,[m
[31m-       25,   29,    0,   29,    0,   29,    0,    0,    0,   29,[m
[31m-       29,   29,    0,    0,    0,    0,    0,    0,    0,    0,[m
[31m-        0,   29,   31,    0,    0,    0,   31,    0,   31,    0,[m
[31m-       31,   31,   31,    0,    0,    0,    0,    0,    0,    0,[m
[31m-        0,    0,   31,   32,    0,   32,    0,    0,    0,    0,[m
[31m-        0,    0,   32,   32,   32,   32,   32,   32,   32,   39,[m
[31m-        0,    0,    0,   39,    0,    0,    0,   39,   39,   39,[m
[31m-       39,    0,    0,    0,    0,    0,    0,    0,    0,   39,[m
[31m-       42,    0,    0,    0,   42,    0,    0,    0,   42,   42,[m
[31m-[m
[31m-       42,   42,    0,    0,    0,    0,    0,    0,    0,    0,[m
[31m-       42,   44,    0,   44,    0,    0,    0,    0,    0,    0,[m
[31m-        0,    0,    0,    0,    0,    0,   44,   44,   45,    0,[m
[31m-        0,    0,   45,   45,   45,    0,    0,    0,    0,    0,[m
[31m-        0,    0,    0,    0,   45,   47,    0,    0,    0,   47,[m
[31m-       47,   47,    0,    0,    0,    0,    0,    0,    0,    0,[m
[31m-        0,   47,   51,    0,   51,    0,   51,    0,    0,    0,[m
[31m-       51,   51,   51,    0,    0,    0,    0,    0,    0,    0,[m
[31m-        0,    0,   51,   55,    0,    0,    0,   55,    0,   55,[m
[31m-        0,   55,   55,   55,    0,    0,    0,    0,    0,    0,[m
[31m-[m
[31m-        0,    0,    0,   55,   59,    0,    0,    0,   59,    0,[m
[31m-       59,    0,   59,   59,   59,    0,    0,    0,    0,    0,[m
[31m-        0,    0,    0,    0,   59,   64,    0,    0,    0,   64,[m
[31m-        0,    0,    0,   64,   64,   64,   64,    0,    0,    0,[m
[31m-        0,    0,    0,    0,    0,   64,   68,    0,   68,    0,[m
[31m-        0,    0,    0,    0,    0,    0,    0,    0,    0,   68,[m
[31m-        0,    0,   68,   69,    0,    0,    0,   69,   69,   69,[m
[31m-        0,    0,    0,    0,    0,    0,    0,    0,    0,   69,[m
[31m-       75,    0,    0,    0,   75,    0,   75,    0,   75,   75,[m
[31m-       75,    0,    0,    0,    0,    0,    0,    0,    0,    0,[m
[31m-[m
[31m-       75,   81,    0,   81,    0,    0,    0,    0,    0,    0,[m
[31m-        0,   81,    0,    0,    0,    0,    0,   81,   83,    0,[m
[31m-       83,    0,    0,    0,    0,    0,    0,    0,    0,   83,[m
[31m-        0,    0,    0,    0,   83,   86,   86,   86,   88,   88,[m
[31m-       91,   91,   94,   94,   95,   95,   96,   96,   97,   97,[m
[31m-       99,   99,  100,  100,  101,  101,  104,  104,  105,  105,[m
[31m-      106,  106,  107,  107,  108,  108,  110,  110,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,[m
[31m-       85,   85,   85[m
[31m-[m
[31m-    } ;[m
[31m-[m
[31m-/* Table of booleans, true if rule could match eol. */[m
[31m-static const flex_int32_t yy_rule_can_match_eol[20] =[m
[31m-    {   0,[m
[31m-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, [m
[31m-        };[m
[31m-[m
[31m-static yy_state_type yy_last_accepting_state;[m
[31m-static char *yy_last_accepting_cpos;[m
[31m-[m
[31m-extern int yy_flex_debug;[m
[31m-int yy_flex_debug = 0;[m
[31m-[m
[31m-/* The intent behind this definition is that it'll catch[m
[31m- * any uses of REJECT which flex missed.[m
[31m- */[m
[31m-#define REJECT reject_used_but_not_detected[m
[31m-#define yymore() yymore_used_but_not_detected[m
[31m-#define YY_MORE_ADJ 0[m
[31m-#define YY_RESTORE_YY_MORE_OFFSET[m
[31m-#ifndef YYLMAX[m
[31m-#define YYLMAX 8192[m
[31m-#endif[m
[31m-[m
[31m-char yytext[YYLMAX];[m
[31m-char *yytext_ptr;[m
[31m-#line 1 "shell.l"[m
[31m-/*[m
[31m- *[m
[31m- * CS-252 [m
[31m- * shell.l: lexical analyzer for shell[m
[31m- * You have to extend it.[m
[31m- *[m
[31m- */[m
[31m-[m
[31m-#line 13 "shell.l"[m
[31m-[m
[31m-#include <cstring>[m
[31m-#include <string.h>[m
[31m-#include "y.tab.hh"[m
[31m-#include <unistd.h>[m
[31m-[m
[31m-extern "C" char * read_line();[m
[31m-[m
[31m-int mygetc(FILE *f) {[m
[31m-  static char *p;[m
[31m-  char ch;[m
[31m-[m
[31m-  if (!isatty(0)) {[m
[31m-    return getc(f);[m
[31m-  }[m
[31m-  if (p == NULL || *p == 0) {[m
[31m-    char *s = read_line();[m
[31m-    p = s;[m
[31m-  }[m
[31m-  ch = *p;[m
[31m-  p++;[m
[31m-  return ch;[m
[31m-}[m
[31m-[m
[31m-#undef getc[m
[31m-#define getc(f) mygetc(f)[m
[31m-[m
[31m-static  void yyunput (int c,char *buf_ptr  );[m
[31m-[m
[31m-void myunputc(int c) {[m
[31m-  unput(c);[m
[31m-}[m
[31m-[m
[31m-#line 677 "lex.yy.cc"[m
[31m-#line 678 "lex.yy.cc"[m
[31m-[m
[31m-#define INITIAL 0[m
[31m-#define sour 1[m
[31m-[m
[31m-#ifndef YY_NO_UNISTD_H[m
[31m-/* Special case for "unistd.h", since it is non-ANSI. We include it way[m
[31m- * down here because we want the user's section 1 to have been scanned first.[m
[31m- * The user has a chance to override it with an option.[m
[31m- */[m
[31m-#include <unistd.h>[m
[31m-#endif[m
[31m-[m
[31m-#ifndef YY_EXTRA_TYPE[m
[31m-#define YY_EXTRA_TYPE void *[m
[31m-#endif[m
[31m-[m
[31m-static int yy_init_globals ( void );[m
[31m-[m
[31m-/* Accessor methods to globals.[m
[31m-   These are made visible to non-reentrant scanners for convenience. */[m
[31m-[m
[31m-int yylex_destroy ( void );[m
[31m-[m
[31m-int yyget_debug ( void );[m
[31m-[m
[31m-void yyset_debug ( int debug_flag  );[m
[31m-[m
[31m-YY_EXTRA_TYPE yyget_extra ( void );[m
[31m-[m
[31m-void yyset_extra ( YY_EXTRA_TYPE user_defined  );[m
[31m-[m
[31m-FILE *yyget_in ( void );[m
[31m-[m
[31m-void yyset_in  ( FILE * _in_str  );[m
[31m-[m
[31m-FILE *yyget_out ( void );[m
[31m-[m
[31m-void yyset_out  ( FILE * _out_str  );[m
[31m-[m
[31m-			int yyget_leng ( void );[m
[31m-[m
[31m-char *yyget_text ( void );[m
[31m-[m
[31m-int yyget_lineno ( void );[m
[31m-[m
[31m-void yyset_lineno ( int _line_number  );[m
[31m-[m
[31m-/* Macros after this point can all be overridden by user definitions in[m
[31m- * section 1.[m
[31m- */[m
[31m-[m
[31m-#ifndef YY_SKIP_YYWRAP[m
[31m-#ifdef __cplusplus[m
[31m-extern "C" int yywrap ( void );[m
[31m-#else[m
[31m-extern int yywrap ( void );[m
[31m-#endif[m
[31m-#endif[m
[31m-[m
[31m-#ifndef YY_NO_UNPUT[m
[31m-    [m
[31m-    static void yyunput ( int c, char *buf_ptr  );[m
[31m-    [m
[31m-#endif[m
[31m-[m
[31m-#ifndef yytext_ptr[m
[31m-static void yy_flex_strncpy ( char *, const char *, int );[m
[31m-#endif[m
[31m-[m
[31m-#ifdef YY_NEED_STRLEN[m
[31m-static int yy_flex_strlen ( const char * );[m
[31m-#endif[m
[31m-[m
[31m-#ifndef YY_NO_INPUT[m
[31m-#ifdef __cplusplus[m
[31m-static int yyinput ( void );[m
[31m-#else[m
[31m-static int input ( void );[m
[31m-#endif[m
[31m-[m
[31m-#endif[m
[31m-[m
[31m-/* Amount of stuff to slurp up with each read. */[m
[31m-#ifndef YY_READ_BUF_SIZE[m
[31m-#ifdef __ia64__[m
[31m-/* On IA-64, the buffer size is 16k, not 8k */[m
[31m-#define YY_READ_BUF_SIZE 16384[m
[31m-#else[m
[31m-#define YY_READ_BUF_SIZE 8192[m
[31m-#endif /* __ia64__ */[m
[31m-#endif[m
[31m-[m
[31m-/* Copy whatever the last rule matched to the standard output. */[m
[31m-#ifndef ECHO[m
[31m-/* This used to be an fputs(), but since the string might contain NUL's,[m
[31m- * we now use fwrite().[m
[31m- */[m
[31m-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)[m
[31m-#endif[m
[31m-[m
[31m-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,[m
[31m- * is returned in "result".[m
[31m- */[m
[31m-#ifndef YY_INPUT[m
[31m-#define YY_INPUT(buf,result,max_size) \[m
[31m-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \[m
[31m-		{ \[m
[31m-		int c = '*'; \[m
[31m-		int n; \[m
[31m-		for ( n = 0; n < max_size && \[m
[31m-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \[m
[31m-			buf[n] = (char) c; \[m
[31m-		if ( c == '\n' ) \[m
[31m-			buf[n++] = (char) c; \[m
[31m-		if ( c == EOF && ferror( yyin ) ) \[m
[31m-			YY_FATAL_ERROR( "input in flex scanner failed" ); \[m
[31m-		result = n; \[m
[31m-		} \[m
[31m-	else \[m
[31m-		{ \[m
[31m-		errno=0; \[m
[31m-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \[m
[31m-			{ \[m
[31m-			if( errno != EINTR) \[m
[31m-				{ \[m
[31m-				YY_FATAL_ERROR( "input in flex scanner failed" ); \[m
[31m-				break; \[m
[31m-				} \[m
[31m-			errno=0; \[m
[31m-			clearerr(yyin); \[m
[31m-			} \[m
[31m-		}\[m
[31m-\[m
[31m-[m
[31m-#endif[m
[31m-[m
[31m-/* No semi-colon after return; correct usage is to write "yyterminate();" -[m
[31m- * we don't want an extra ';' after the "return" because that will cause[m
[31m- * some compilers to complain about unreachable statements.[m
[31m- */[m
[31m-#ifndef yyterminate[m
[31m-#define yyterminate() return YY_NULL[m
[31m-#endif[m
[31m-[m
[31m-/* Number of entries by which start-condition stack grows. */[m
[31m-#ifndef YY_START_STACK_INCR[m
[31m-#define YY_START_STACK_INCR 25[m
[31m-#endif[m
[31m-[m
[31m-/* Report a fatal error. */[m
[31m-#ifndef YY_FATAL_ERROR[m
[31m-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )[m
[31m-#endif[m
[31m-[m
[31m-/* end tables serialization structures and prototypes */[m
[31m-[m
[31m-/* Default declaration of generated scanner - a define so the user can[m
[31m- * easily add parameters.[m
[31m- */[m
[31m-#ifndef YY_DECL[m
[31m-#define YY_DECL_IS_OURS 1[m
[31m-[m
[31m-extern int yylex (void);[m
[31m-[m
[31m-#define YY_DECL int yylex (void)[m
[31m-#endif /* !YY_DECL */[m
[31m-[m
[31m-/* Code executed at the beginning of each rule, after yytext and yyleng[m
[31m- * have been set up.[m
[31m- */[m
[31m-#ifndef YY_USER_ACTION[m
[31m-#define YY_USER_ACTION[m
[31m-#endif[m
[31m-[m
[31m-/* Code executed at the end of each rule. */[m
[31m-#ifndef YY_BREAK[m
[31m-#define YY_BREAK /*LINTED*/break;[m
[31m-#endif[m
[31m-[m
[31m-#define YY_RULE_SETUP \[m
[31m-	YY_USER_ACTION[m
[31m-[m
[31m-/** The main scanner function which does all the work.[m
[31m- */[m
[31m-YY_DECL[m
[31m-{[m
[31m-	yy_state_type yy_current_state;[m
[31m-	char *yy_cp, *yy_bp;[m
[31m-	int yy_act;[m
[31m-    [m
[31m-	if ( !(yy_init) )[m
[31m-		{[m
[31m-		(yy_init) = 1;[m
[31m-[m
[31m-#ifdef YY_USER_INIT[m
[31m-		YY_USER_INIT;[m
[31m-#endif[m
[31m-[m
[31m-		if ( ! (yy_start) )[m
[31m-			(yy_start) = 1;	/* first start state */[m
[31m-[m
[31m-		if ( ! yyin )[m
[31m-			yyin = stdin;[m
[31m-[m
[31m-		if ( ! yyout )[m
[31m-			yyout = stdout;[m
[31m-[m
[31m-		if ( ! YY_CURRENT_BUFFER ) {[m
[31m-			yyensure_buffer_stack ();[m
[31m-			YY_CURRENT_BUFFER_LVALUE =[m
[31m-				yy_create_buffer( yyin, YY_BUF_SIZE );[m
[31m-		}[m
[31m-[m
[31m-		yy_load_buffer_state(  );[m
[31m-		}[m
[31m-[m
[31m-	{[m
[31m-#line 50 "shell.l"[m
[31m-[m
[31m-[m
[31m-#line 899 "lex.yy.cc"[m
[31m-[m
[31m-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */[m
[31m-		{[m
[31m-		yy_cp = (yy_c_buf_p);[m
[31m-[m
[31m-		/* Support of yytext. */[m
[31m-		*yy_cp = (yy_hold_char);[m
[31m-[m
[31m-		/* yy_bp points to the position in yy_ch_buf of the start of[m
[31m-		 * the current run.[m
[31m-		 */[m
[31m-		yy_bp = yy_cp;[m
[31m-[m
[31m-		yy_current_state = (yy_start);[m
[31m-yy_match:[m
[31m-		do[m
[31m-			{[m
[31m-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;[m
[31m-			if ( yy_accept[yy_current_state] )[m
[31m-				{[m
[31m-				(yy_last_accepting_state) = yy_current_state;[m
[31m-				(yy_last_accepting_cpos) = yy_cp;[m
[31m-				}[m
[31m-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )[m
[31m-				{[m
[31m-				yy_current_state = (int) yy_def[yy_current_state];[m
[31m-				if ( yy_current_state >= 86 )[m
[31m-					yy_c = yy_meta[yy_c];[m
[31m-				}[m
[31m-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];[m
[31m-			++yy_cp;[m
[31m-			}[m
[31m-		while ( yy_base[yy_current_state] != 569 );[m
[31m-[m
[31m-yy_find_action:[m
[31m-		yy_act = yy_accept[yy_current_state];[m
[31m-		if ( yy_act == 0 )[m
[31m-			{ /* have to back up */[m
[31m-			yy_cp = (yy_last_accepting_cpos);[m
[31m-			yy_current_state = (yy_last_accepting_state);[m
[31m-			yy_act = yy_accept[yy_current_state];[m
[31m-			}[m
[31m-[m
[31m-		YY_DO_BEFORE_ACTION;[m
[31m-[m
[31m-		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )[m
[31m-			{[m
[31m-			int yyl;[m
[31m-			for ( yyl = 0; yyl < yyleng; ++yyl )[m
[31m-				if ( yytext[yyl] == '\n' )[m
[31m-					[m
[31m-    yylineno++;[m
[31m-;[m
[31m-			}[m
[31m-[m
[31m-do_action:	/* This label is used only to access EOF actions. */[m
[31m-[m
[31m-		switch ( yy_act )[m
[31m-	{ /* beginning of action switch */[m
[31m-			case 0: /* must back up */[m
[31m-			/* undo the effects of YY_DO_BEFORE_ACTION */[m
[31m-			*yy_cp = (yy_hold_char);[m
[31m-			yy_cp = (yy_last_accepting_cpos);[m
[31m-			yy_current_state = (yy_last_accepting_state);[m
[31m-			goto yy_find_action;[m
[31m-[m
[31m-case 1:[m
[31m-/* rule 1 can match eol */[m
[31m-YY_RULE_SETUP[m
[31m-#line 52 "shell.l"[m
[31m-{[m
[31m-  return NEWLINE;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 2:[m
[31m-YY_RULE_SETUP[m
[31m-#line 56 "shell.l"[m
[31m-{[m
[31m-  /* Discard spaces and tabs */[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 3:[m
[31m-YY_RULE_SETUP[m
[31m-#line 60 "shell.l"[m
[31m-{[m
[31m-  return GREATGREATAMPERSAND;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 4:[m
[31m-YY_RULE_SETUP[m
[31m-#line 64 "shell.l"[m
[31m-{[m
[31m-  return GREATAMPERSAND;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 5:[m
[31m-YY_RULE_SETUP[m
[31m-#line 68 "shell.l"[m
[31m-{[m
[31m-  return TWOGREAT;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 6:[m
[31m-YY_RULE_SETUP[m
[31m-#line 72 "shell.l"[m
[31m-{[m
[31m-  return GREATGREAT;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 7:[m
[31m-YY_RULE_SETUP[m
[31m-#line 76 "shell.l"[m
[31m-{[m
[31m-  return GREAT;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 8:[m
[31m-YY_RULE_SETUP[m
[31m-#line 80 "shell.l"[m
[31m-{[m
[31m-  return LESS;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 9:[m
[31m-YY_RULE_SETUP[m
[31m-#line 84 "shell.l"[m
[31m-{[m
[31m-  return AMPERSAND;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 10:[m
[31m-YY_RULE_SETUP[m
[31m-#line 88 "shell.l"[m
[31m-{[m
[31m-  return PIPE;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 11:[m
[31m-YY_RULE_SETUP[m
[31m-#line 92 "shell.l"[m
[31m-{[m
[31m-  std::string text = std::string(yytext);[m
[31m-  text = text.substr(1, text.length() - 2);[m
[31m-  yylval.cpp_string = new std::string(text);[m
[31m-  return WORD;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 12:[m
[31m-YY_RULE_SETUP[m
[31m-#line 99 "shell.l"[m
[31m-{[m
[31m-  std::string text = std::string(yytext);[m
[31m-  if (text.length() == 1) {[m
[31m-    yylval.cpp_string = new std::string(getenv("HOME"));[m
[31m-  } else {[m
[31m-    if (text.find("/") != std::string::npos) {[m
[31m-      text = std::string("/homes/")  + text.substr(1, text.length()-1);[m
[31m-      yylval.cpp_string = new std::string(text);[m
[31m-    } else {[m
[31m-      text = std::string("/homes/") + text.substr(1, text.length()-1);[m
[31m-      yylval.cpp_string = new std::string(text);[m
[31m-    }[m
[31m-  }[m
[31m-  return WORD;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 13:[m
[31m-YY_RULE_SETUP[m
[31m-#line 115 "shell.l"[m
[31m-{[m
[31m-  BEGIN(sour);[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 14:[m
[31m-YY_RULE_SETUP[m
[31m-#line 119 "shell.l"[m
[31m-{[m
[31m-  FILE * yyin = fopen(yytext, "r");[m
[31m-  if (!yyin) {[m
[31m-    perror("fopen");[m
[31m-    BEGIN(INITIAL);[m
[31m-  }[m
[31m-  yypush_buffer_state(yy_create_buffer(yyin, YY_BUF_SIZE));[m
[31m-  BEGIN(INITIAL);[m
[31m-  yyparse();[m
[31m-  yypop_buffer_state();[m
[31m-  fclose(yyin);[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 15:[m
[31m-YY_RULE_SETUP[m
[31m-#line 132 "shell.l"[m
[31m-{[m
[31m-  std::string text = std::string(yytext);[m
[31m-  text = text.substr(2, text.length() - 3);[m
[31m-  std::string compiled = getenv(text.c_str());[m
[31m-  yylval.cpp_string = new std::string(compiled);[m
[31m-  return WORD;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 16:[m
[31m-YY_RULE_SETUP[m
[31m-#line 140 "shell.l"[m
[31m-{[m
[31m-  std::string text = std::string(yytext);[m
[31m-  //printf("before: %s\n", text.c_str());[m
[31m-  if (text.find("$") != std::string::npos) {[m
[31m-    text = text.substr(1, text.length()-1);[m
[31m-  }[m
[31m-  text = text.substr(1, text.length()-2);[m
[31m-  text = text + "\nexit\n";[m
[31m-  //printf("before: %s\n", text.c_str());[m
[31m-  //text = text + '\0';[m
[31m-//  printf("text; %s\n", text.c_str());[m
[31m-  char * readbuffer = ((char *) malloc(sizeof(char) * 1024));[m
[31m-[m
[31m-  int infd;[m
[31m-  int outfd;[m
[31m-  infd = dup(0);[m
[31m-  outfd = dup(1);[m
[31m-[m
[31m-  int pin[2];[m
[31m-  int pout[2];[m
[31m-  pipe(pin);[m
[31m-  pipe(pout);[m
[31m-[m
[31m-  dup2(pin[0], 0);[m
[31m-  dup2(pout[1], 1);[m
[31m-  close(pin[0]);[m
[31m-  close(pout[1]);[m
[31m-[m
[31m-  write(pin[1], text.c_str(), text.length());[m
[31m-[m
[31m-  close(pin[1]);[m
[31m-[m
[31m-  int ret;[m
[31m-  ret = fork();[m
[31m-  if (ret == 0){[m
[31m-[m
[31m-    const char * path = "/proc/self/exe";[m
[31m-    char ** argument = new char*[strlen(path) + 1];[m
[31m-    execvp(path, argument);[m
[31m-    perror("excvp");[m
[31m-    exit(1);[m
[31m-[m
[31m-  } else if (ret < 0) {[m
[31m-    perror("fork");[m
[31m-    exit(1);[m
[31m-  }  // waitpid(ret, NULL, 0);[m
[31m-  dup2(infd, 0);[m
[31m-  dup2(outfd, 1);[m
[31m-  close(infd);[m
[31m-  close(outfd);[m
[31m-[m
[31m-  char reading;[m
[31m-  int i = 0;[m
[31m-  while (read(pout[0], &reading, 1)) {[m
[31m-    if (reading == '\n') {[m
[31m-      readbuffer[i++] = ' ';[m
[31m-    } else {[m
[31m-      readbuffer[i++] = reading;[m
[31m-    }[m
[31m-  }[m
[31m-  readbuffer[i] = '\0';[m
[31m-  //close(pout[0]);[m
[31m-  //printf("rbuffer: %s, nbytes: %d\n", readbuffer, nbytes);[m
[31m-  for (i = strlen(readbuffer) - 12; i >= 0; i--) {[m
[31m-    unput(readbuffer[i]);[m
[31m-  }[m
[31m-[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 17:[m
[31m-YY_RULE_SETUP[m
[31m-#line 209 "shell.l"[m
[31m-{[m
[31m-  int length = strlen(yytext);[m
[31m-  char * text = ((char *) malloc(sizeof(char) * length));[m
[31m-  char * original = yytext;[m
[31m-  int j = 0;[m
[31m-  for (int i = 0; i != strlen(original); i++) {[m
[31m-    if (original[i] == '\\') {[m
[31m-      if (original[i+1] == '\\') {[m
[31m-        text[j] = original[i+1];[m
[31m-        i++;[m
[31m-        j++;[m
[31m-      }[m
[31m-    } else {[m
[31m-      text[j] = original[i];[m
[31m-      j++;[m
[31m-    }[m
[31m-  }[m
[31m-[m
[31m-  yylval.cpp_string = new std::string(text);[m
[31m-[m
[31m-  return WORD;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 18:[m
[31m-YY_RULE_SETUP[m
[31m-#line 232 "shell.l"[m
[31m-{[m
[31m-  /* Assume that file names have only alpha chars */[m
[31m-  yylval.cpp_string = new std::string(yytext);[m
[31m-  return WORD;[m
[31m-}[m
[31m-	YY_BREAK[m
[31m-case 19:[m
[31m-YY_RULE_SETUP[m
[31m-#line 237 "shell.l"[m
[31m-ECHO;[m
[31m-	YY_BREAK[m
[31m-#line 1212 "lex.yy.cc"[m
[31m-case YY_STATE_EOF(INITIAL):[m
[31m-case YY_STATE_EOF(sour):[m
[31m-	yyterminate();[m
[31m-[m
[31m-	case YY_END_OF_BUFFER:[m
[31m-		{[m
[31m-		/* Amount of text matched not including the EOB char. */[m
[31m-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;[m
[31m-[m
[31m-		/* Undo the effects of YY_DO_BEFORE_ACTION. */[m
[31m-		*yy_cp = (yy_hold_char);[m
[31m-		YY_RESTORE_YY_MORE_OFFSET[m
[31m-[m
[31m-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )[m
[31m-			{[m
[31m-			/* We're scanning a new file or input source.  It's[m
[31m-			 * possible that this happened because the user[m
[31m-			 * just pointed yyin at a new source and called[m
[31m-			 * yylex().  If so, then we have to assure[m
[31m-			 * consistency between YY_CURRENT_BUFFER and our[m
[31m-			 * globals.  Here is the right place to do so, because[m
[31m-			 * this is the first action (other than possibly a[m
[31m-			 * back-up) that will match for the new input source.[m
[31m-			 */[m
[31m-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;[m
[31m-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;[m
[31m-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;[m
[31m-			}[m
[31m-[m
[31m-		/* Note that here we test for yy_c_buf_p "<=" to the position[m
[31m-		 * of the first EOB in the buffer, since yy_c_buf_p will[m
[31m-		 * already have been incremented past the NUL character[m
[31m-		 * (since all states make transitions on EOB to the[m
[31m-		 * end-of-buffer state).  Contrast this with the test[m
[31m-		 * in input().[m
[31m-		 */[m
[31m-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )[m
[31m-			{ /* This was really a NUL. */[m
[31m-			yy_state_type yy_next_state;[m
[31m-[m
[31m-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;[m
[31m-[m
[31m-			yy_current_state = yy_get_previous_state(  );[m
[31m-[m
[31m-			/* Okay, we're now positioned to make the NUL[m
[31m-			 * transition.  We couldn't have[m
[31m-			 * yy_get_previous_state() go ahead and do it[m
[31m-			 * for us because it doesn't know how to deal[m
[31m-			 * with the possibility of jamming (and we don't[m
[31m-			 * want to build jamming into it because then it[m
[31m-			 * will run more slowly).[m
[31m-			 */[m
[31m-[m
[31m-			yy_next_state = yy_try_NUL_trans( yy_current_state );[m
[31m-[m
[31m-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;[m
[31m-[m
[31m-			if ( yy_next_state )[m
[31m-				{[m
[31m-				/* Consume the NUL. */[m
[31m-				yy_cp = ++(yy_c_buf_p);[m
[31m-				yy_current_state = yy_next_state;[m
[31m-				goto yy_match;[m
[31m-				}[m
[31m-[m
[31m-			else[m
[31m-				{[m
[31m-				yy_cp = (yy_c_buf_p);[m
[31m-				goto yy_find_action;[m
[31m-				}[m
[31m-			}[m
[31m-[m
[31m-		else switch ( yy_get_next_buffer(  ) )[m
[31m-			{[m
[31m-			case EOB_ACT_END_OF_FILE:[m
[31m-				{[m
[31m-				(yy_did_buffer_switch_on_eof) = 0;[m
[31m-[m
[31m-				if ( yywrap(  ) )[m
[31m-					{[m
[31m-					/* Note: because we've taken care in[m
[31m-					 * yy_get_next_buffer() to have set up[m
[31m-					 * yytext, we can now set up[m
[31m-					 * yy_c_buf_p so that if some total[m
[31m-					 * hoser (like flex itself) wants to[m
[31m-					 * call the scanner after we return the[m
[31m-					 * YY_NULL, it'll still work - another[m
[31m-					 * YY_NULL will get returned.[m
[31m-					 */[m
[31m-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;[m
[31m-[m
[31m-					yy_act = YY_STATE_EOF(YY_START);[m
[31m-					goto do_action;[m
[31m-					}[m
[31m-[m
[31m-				else[m
[31m-					{[m
[31m-					if ( ! (yy_did_buffer_switch_on_eof) )[m
[31m-						YY_NEW_FILE;[m
[31m-					}[m
[31m-				break;[m
[31m-				}[m
[31m-[m
[31m-			case EOB_ACT_CONTINUE_SCAN:[m
[31m-				(yy_c_buf_p) =[m
[31m-					(yytext_ptr) + yy_amount_of_matched_text;[m
[31m-[m
[31m-				yy_current_state = yy_get_previous_state(  );[m
[31m-[m
[31m-				yy_cp = (yy_c_buf_p);[m
[31m-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;[m
[31m-				goto yy_match;[m
[31m-[m
[31m-			case EOB_ACT_LAST_MATCH:[m
[31m-				(yy_c_buf_p) =[m
[31m-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];[m
[31m-[m
[31m-				yy_current_state = yy_get_previous_state(  );[m
[31m-[m
[31m-				yy_cp = (yy_c_buf_p);[m
[31m-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;[m
[31m-				goto yy_find_action;[m
[31m-			}[m
[31m-		break;[m
[31m-		}[m
[31m-[m
[31m-	default:[m
[31m-		YY_FATAL_ERROR([m
[31m-			"fatal flex scanner internal error--no action found" );[m
[31m-	} /* end of action switch */[m
[31m-		} /* end of scanning one token */[m
[31m-	} /* end of user's declarations */[m
[31m-} /* end of yylex */[m
[31m-[m
[31m-/* yy_get_next_buffer - try to read in a new buffer[m
[31m- *[m
[31m- * Returns a code representing an action:[m
[31m- *	EOB_ACT_LAST_MATCH -[m
[31m- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position[m
[31m- *	EOB_ACT_END_OF_FILE - end of file[m
[31m- */[m
[31m-static int yy_get_next_buffer (void)[m
[31m-{[m
[31m-    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;[m
[31m-	char *source = (yytext_ptr);[m
[31m-	int number_to_move, i;[m
[31m-	int ret_val;[m
[31m-[m
[31m-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )[m
[31m-		YY_FATAL_ERROR([m
[31m-		"fatal flex scanner internal error--end of buffer missed" );[m
[31m-[m
[31m-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )[m
[31m-		{ /* Don't try to fill the buffer, so this is an EOF. */[m
[31m-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )[m
[31m-			{[m
[31m-			/* We matched a single character, the EOB, so[m
[31m-			 * treat this as a final EOF.[m
[31m-			 */[m
[31m-			return EOB_ACT_END_OF_FILE;[m
[31m-			}[m
[31m-[m
[31m-		else[m
[31m-			{[m
[31m-			/* We matched some text prior to the EOB, first[m
[31m-			 * process it.[m
[31m-			 */[m
[31m-			return EOB_ACT_LAST_MATCH;[m
[31m-			}[m
[31m-		}[m
[31m-[m
[31m-	/* Try to read more data. */[m
[31m-[m
[31m-	/* First move last chars to start of buffer. */[m
[31m-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);[m
[31m-[m
[31m-	for ( i = 0; i < number_to_move; ++i )[m
[31m-		*(dest++) = *(source++);[m
[31m-[m
[31m-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )[m
[31m-		/* don't do the read, it's not guaranteed to return an EOF,[m
[31m-		 * just force an EOF[m
[31m-		 */[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;[m
[31m-[m
[31m-	else[m
[31m-		{[m
[31m-			int num_to_read =[m
[31m-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;[m
[31m-[m
[31m-		while ( num_to_read <= 0 )[m
[31m-			{ /* Not enough room in the buffer - grow it. */[m
[31m-[m
[31m-			/* just a shorter name for the current buffer */[m
[31m-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;[m
[31m-[m
[31m-			int yy_c_buf_p_offset =[m
[31m-				(int) ((yy_c_buf_p) - b->yy_ch_buf);[m
[31m-[m
[31m-			if ( b->yy_is_our_buffer )[m
[31m-				{[m
[31m-				int new_size = b->yy_buf_size * 2;[m
[31m-[m
[31m-				if ( new_size <= 0 )[m
[31m-					b->yy_buf_size += b->yy_buf_size / 8;[m
[31m-				else[m
[31m-					b->yy_buf_size *= 2;[m
[31m-[m
[31m-				b->yy_ch_buf = (char *)[m
[31m-					/* Include room in for 2 EOB chars. */[m
[31m-					yyrealloc( (void *) b->yy_ch_buf,[m
[31m-							 (yy_size_t) (b->yy_buf_size + 2)  );[m
[31m-				}[m
[31m-			else[m
[31m-				/* Can't grow it, we don't own it. */[m
[31m-				b->yy_ch_buf = NULL;[m
[31m-[m
[31m-			if ( ! b->yy_ch_buf )[m
[31m-				YY_FATAL_ERROR([m
[31m-				"fatal error - scanner input buffer overflow" );[m
[31m-[m
[31m-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];[m
[31m-[m
[31m-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -[m
[31m-						number_to_move - 1;[m
[31m-[m
[31m-			}[m
[31m-[m
[31m-		if ( num_to_read > YY_READ_BUF_SIZE )[m
[31m-			num_to_read = YY_READ_BUF_SIZE;[m
[31m-[m
[31m-		/* Read in more data. */[m
[31m-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),[m
[31m-			(yy_n_chars), num_to_read );[m
[31m-[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);[m
[31m-		}[m
[31m-[m
[31m-	if ( (yy_n_chars) == 0 )[m
[31m-		{[m
[31m-		if ( number_to_move == YY_MORE_ADJ )[m
[31m-			{[m
[31m-			ret_val = EOB_ACT_END_OF_FILE;[m
[31m-			yyrestart( yyin  );[m
[31m-			}[m
[31m-[m
[31m-		else[m
[31m-			{[m
[31m-			ret_val = EOB_ACT_LAST_MATCH;[m
[31m-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =[m
[31m-				YY_BUFFER_EOF_PENDING;[m
[31m-			}[m
[31m-		}[m
[31m-[m
[31m-	else[m
[31m-		ret_val = EOB_ACT_CONTINUE_SCAN;[m
[31m-[m
[31m-	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {[m
[31m-		/* Extend the array by 50%, plus the number we really need. */[m
[31m-		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc([m
[31m-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );[m
[31m-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )[m
[31m-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );[m
[31m-		/* "- 2" to take care of EOB's */[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);[m
[31m-	}[m
[31m-[m
[31m-	(yy_n_chars) += number_to_move;[m
[31m-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;[m
[31m-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;[m
[31m-[m
[31m-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];[m
[31m-[m
[31m-	return ret_val;[m
[31m-}[m
[31m-[m
[31m-/* yy_get_previous_state - get the state just before the EOB char was reached */[m
[31m-[m
[31m-    static yy_state_type yy_get_previous_state (void)[m
[31m-{[m
[31m-	yy_state_type yy_current_state;[m
[31m-	char *yy_cp;[m
[31m-    [m
[31m-	yy_current_state = (yy_start);[m
[31m-[m
[31m-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )[m
[31m-		{[m
[31m-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);[m
[31m-		if ( yy_accept[yy_current_state] )[m
[31m-			{[m
[31m-			(yy_last_accepting_state) = yy_current_state;[m
[31m-			(yy_last_accepting_cpos) = yy_cp;[m
[31m-			}[m
[31m-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )[m
[31m-			{[m
[31m-			yy_current_state = (int) yy_def[yy_current_state];[m
[31m-			if ( yy_current_state >= 86 )[m
[31m-				yy_c = yy_meta[yy_c];[m
[31m-			}[m
[31m-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];[m
[31m-		}[m
[31m-[m
[31m-	return yy_current_state;[m
[31m-}[m
[31m-[m
[31m-/* yy_try_NUL_trans - try to make a transition on the NUL character[m
[31m- *[m
[31m- * synopsis[m
[31m- *	next_state = yy_try_NUL_trans( current_state );[m
[31m- */[m
[31m-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )[m
[31m-{[m
[31m-	int yy_is_jam;[m
[31m-    	char *yy_cp = (yy_c_buf_p);[m
[31m-[m
[31m-	YY_CHAR yy_c = 1;[m
[31m-	if ( yy_accept[yy_current_state] )[m
[31m-		{[m
[31m-		(yy_last_accepting_state) = yy_current_state;[m
[31m-		(yy_last_accepting_cpos) = yy_cp;[m
[31m-		}[m
[31m-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )[m
[31m-		{[m
[31m-		yy_current_state = (int) yy_def[yy_current_state];[m
[31m-		if ( yy_current_state >= 86 )[m
[31m-			yy_c = yy_meta[yy_c];[m
[31m-		}[m
[31m-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];[m
[31m-	yy_is_jam = (yy_current_state == 85);[m
[31m-[m
[31m-		return yy_is_jam ? 0 : yy_current_state;[m
[31m-}[m
[31m-[m
[31m-#ifndef YY_NO_UNPUT[m
[31m-[m
[31m-    static void yyunput (int c, char * yy_bp )[m
[31m-{[m
[31m-	char *yy_cp;[m
[31m-    [m
[31m-    yy_cp = (yy_c_buf_p);[m
[31m-[m
[31m-	/* undo effects of setting up yytext */[m
[31m-	*yy_cp = (yy_hold_char);[m
[31m-[m
[31m-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )[m
[31m-		{ /* need to shift things up to make room */[m
[31m-		/* +2 for EOB chars. */[m
[31m-		int number_to_move = (yy_n_chars) + 2;[m
[31m-		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[[m
[31m-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];[m
[31m-		char *source =[m
[31m-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];[m
[31m-[m
[31m-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )[m
[31m-			*--dest = *--source;[m
[31m-[m
[31m-		yy_cp += (int) (dest - source);[m
[31m-		yy_bp += (int) (dest - source);[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =[m
[31m-			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;[m
[31m-[m
[31m-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )[m
[31m-			YY_FATAL_ERROR( "flex scanner push-back overflow" );[m
[31m-		}[m
[31m-[m
[31m-	*--yy_cp = (char) c;[m
[31m-[m
[31m-    if ( c == '\n' ){[m
[31m-        --yylineno;[m
[31m-    }[m
[31m-[m
[31m-	(yytext_ptr) = yy_bp;[m
[31m-	(yy_hold_char) = *yy_cp;[m
[31m-	(yy_c_buf_p) = yy_cp;[m
[31m-}[m
[31m-[m
[31m-#endif[m
[31m-[m
[31m-#ifndef YY_NO_INPUT[m
[31m-#ifdef __cplusplus[m
[31m-    static int yyinput (void)[m
[31m-#else[m
[31m-    static int input  (void)[m
[31m-#endif[m
[31m-[m
[31m-{[m
[31m-	int c;[m
[31m-    [m
[31m-	*(yy_c_buf_p) = (yy_hold_char);[m
[31m-[m
[31m-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )[m
[31m-		{[m
[31m-		/* yy_c_buf_p now points to the character we want to return.[m
[31m-		 * If this occurs *before* the EOB characters, then it's a[m
[31m-		 * valid NUL; if not, then we've hit the end of the buffer.[m
[31m-		 */[m
[31m-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )[m
[31m-			/* This was really a NUL. */[m
[31m-			*(yy_c_buf_p) = '\0';[m
[31m-[m
[31m-		else[m
[31m-			{ /* need more input */[m
[31m-			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));[m
[31m-			++(yy_c_buf_p);[m
[31m-[m
[31m-			switch ( yy_get_next_buffer(  ) )[m
[31m-				{[m
[31m-				case EOB_ACT_LAST_MATCH:[m
[31m-					/* This happens because yy_g_n_b()[m
[31m-					 * sees that we've accumulated a[m
[31m-					 * token and flags that we need to[m
[31m-					 * try matching the token before[m
[31m-					 * proceeding.  But for input(),[m
[31m-					 * there's no matching to consider.[m
[31m-					 * So convert the EOB_ACT_LAST_MATCH[m
[31m-					 * to EOB_ACT_END_OF_FILE.[m
[31m-					 */[m
[31m-[m
[31m-					/* Reset buffer status. */[m
[31m-					yyrestart( yyin );[m
[31m-[m
[31m-					/*FALLTHROUGH*/[m
[31m-[m
[31m-				case EOB_ACT_END_OF_FILE:[m
[31m-					{[m
[31m-					if ( yywrap(  ) )[m
[31m-						return 0;[m
[31m-[m
[31m-					if ( ! (yy_did_buffer_switch_on_eof) )[m
[31m-						YY_NEW_FILE;[m
[31m-#ifdef __cplusplus[m
[31m-					return yyinput();[m
[31m-#else[m
[31m-					return input();[m
[31m-#endif[m
[31m-					}[m
[31m-[m
[31m-				case EOB_ACT_CONTINUE_SCAN:[m
[31m-					(yy_c_buf_p) = (yytext_ptr) + offset;[m
[31m-					break;[m
[31m-				}[m
[31m-			}[m
[31m-		}[m
[31m-[m
[31m-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */[m
[31m-	*(yy_c_buf_p) = '\0';	/* preserve yytext */[m
[31m-	(yy_hold_char) = *++(yy_c_buf_p);[m
[31m-[m
[31m-	if ( c == '\n' )[m
[31m-		[m
[31m-    yylineno++;[m
[31m-;[m
[31m-[m
[31m-	return c;[m
[31m-}[m
[31m-#endif	/* ifndef YY_NO_INPUT */[m
[31m-[m
[31m-/** Immediately switch to a different input stream.[m
[31m- * @param input_file A readable stream.[m
[31m- * [m
[31m- * @note This function does not reset the start condition to @c INITIAL .[m
[31m- */[m
[31m-    void yyrestart  (FILE * input_file )[m
[31m-{[m
[31m-    [m
[31m-	if ( ! YY_CURRENT_BUFFER ){[m
[31m-        yyensure_buffer_stack ();[m
[31m-		YY_CURRENT_BUFFER_LVALUE =[m
[31m-            yy_create_buffer( yyin, YY_BUF_SIZE );[m
[31m-	}[m
[31m-[m
[31m-	yy_init_buffer( YY_CURRENT_BUFFER, input_file );[m
[31m-	yy_load_buffer_state(  );[m
[31m-}[m
[31m-[m
[31m-/** Switch to a different input buffer.[m
[31m- * @param new_buffer The new input buffer.[m
[31m- * [m
[31m- */[m
[31m-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )[m
[31m-{[m
[31m-    [m
[31m-	/* TODO. We should be able to replace this entire function body[m
[31m-	 * with[m
[31m-	 *		yypop_buffer_state();[m
[31m-	 *		yypush_buffer_state(new_buffer);[m
[31m-     */[m
[31m-	yyensure_buffer_stack ();[m
[31m-	if ( YY_CURRENT_BUFFER == new_buffer )[m
[31m-		return;[m
[31m-[m
[31m-	if ( YY_CURRENT_BUFFER )[m
[31m-		{[m
[31m-		/* Flush out information for old buffer. */[m
[31m-		*(yy_c_buf_p) = (yy_hold_char);[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);[m
[31m-		}[m
[31m-[m
[31m-	YY_CURRENT_BUFFER_LVALUE = new_buffer;[m
[31m-	yy_load_buffer_state(  );[m
[31m-[m
[31m-	/* We don't actually know whether we did this switch during[m
[31m-	 * EOF (yywrap()) processing, but the only time this flag[m
[31m-	 * is looked at is after yywrap() is called, so it's safe[m
[31m-	 * to go ahead and always set it.[m
[31m-	 */[m
[31m-	(yy_did_buffer_switch_on_eof) = 1;[m
[31m-}[m
[31m-[m
[31m-static void yy_load_buffer_state  (void)[m
[31m-{[m
[31m-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;[m
[31m-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;[m
[31m-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;[m
[31m-	(yy_hold_char) = *(yy_c_buf_p);[m
[31m-}[m
[31m-[m
[31m-/** Allocate and initialize an input buffer state.[m
[31m- * @param file A readable stream.[m
[31m- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.[m
[31m- * [m
[31m- * @return the allocated buffer state.[m
[31m- */[m
[31m-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )[m
[31m-{[m
[31m-	YY_BUFFER_STATE b;[m
[31m-    [m
[31m-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );[m
[31m-	if ( ! b )[m
[31m-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );[m
[31m-[m
[31m-	b->yy_buf_size = size;[m
[31m-[m
[31m-	/* yy_ch_buf has to be 2 characters longer than the size given because[m
[31m-	 * we need to put in 2 end-of-buffer characters.[m
[31m-	 */[m
[31m-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );[m
[31m-	if ( ! b->yy_ch_buf )[m
[31m-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );[m
[31m-[m
[31m-	b->yy_is_our_buffer = 1;[m
[31m-[m
[31m-	yy_init_buffer( b, file );[m
[31m-[m
[31m-	return b;[m
[31m-}[m
[31m-[m
[31m-/** Destroy the buffer.[m
[31m- * @param b a buffer created with yy_create_buffer()[m
[31m- * [m
[31m- */[m
[31m-    void yy_delete_buffer (YY_BUFFER_STATE  b )[m
[31m-{[m
[31m-    [m
[31m-	if ( ! b )[m
[31m-		return;[m
[31m-[m
[31m-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */[m
[31m-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;[m
[31m-[m
[31m-	if ( b->yy_is_our_buffer )[m
[31m-		yyfree( (void *) b->yy_ch_buf  );[m
[31m-[m
[31m-	yyfree( (void *) b  );[m
[31m-}[m
[31m-[m
[31m-/* Initializes or reinitializes a buffer.[m
[31m- * This function is sometimes called more than once on the same buffer,[m
[31m- * such as during a yyrestart() or at EOF.[m
[31m- */[m
[31m-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )[m
[31m-[m
[31m-{[m
[31m-	int oerrno = errno;[m
[31m-    [m
[31m-	yy_flush_buffer( b );[m
[31m-[m
[31m-	b->yy_input_file = file;[m
[31m-	b->yy_fill_buffer = 1;[m
[31m-[m
[31m-    /* If b is the current buffer, then yy_init_buffer was _probably_[m
[31m-     * called from yyrestart() or through yy_get_next_buffer.[m
[31m-     * In that case, we don't want to reset the lineno or column.[m
[31m-     */[m
[31m-    if (b != YY_CURRENT_BUFFER){[m
[31m-        b->yy_bs_lineno = 1;[m
[31m-        b->yy_bs_column = 0;[m
[31m-    }[m
[31m-[m
[31m-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;[m
[31m-    [m
[31m-	errno = oerrno;[m
[31m-}[m
[31m-[m
[31m-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.[m
[31m- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.[m
[31m- * [m
[31m- */[m
[31m-    void yy_flush_buffer (YY_BUFFER_STATE  b )[m
[31m-{[m
[31m-    	if ( ! b )[m
[31m-		return;[m
[31m-[m
[31m-	b->yy_n_chars = 0;[m
[31m-[m
[31m-	/* We always need two end-of-buffer characters.  The first causes[m
[31m-	 * a transition to the end-of-buffer state.  The second causes[m
[31m-	 * a jam in that state.[m
[31m-	 */[m
[31m-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;[m
[31m-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;[m
[31m-[m
[31m-	b->yy_buf_pos = &b->yy_ch_buf[0];[m
[31m-[m
[31m-	b->yy_at_bol = 1;[m
[31m-	b->yy_buffer_status = YY_BUFFER_NEW;[m
[31m-[m
[31m-	if ( b == YY_CURRENT_BUFFER )[m
[31m-		yy_load_buffer_state(  );[m
[31m-}[m
[31m-[m
[31m-/** Pushes the new state onto the stack. The new state becomes[m
[31m- *  the current state. This function will allocate the stack[m
[31m- *  if necessary.[m
[31m- *  @param new_buffer The new state.[m
[31m- *  [m
[31m- */[m
[31m-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )[m
[31m-{[m
[31m-    	if (new_buffer == NULL)[m
[31m-		return;[m
[31m-[m
[31m-	yyensure_buffer_stack();[m
[31m-[m
[31m-	/* This block is copied from yy_switch_to_buffer. */[m
[31m-	if ( YY_CURRENT_BUFFER )[m
[31m-		{[m
[31m-		/* Flush out information for old buffer. */[m
[31m-		*(yy_c_buf_p) = (yy_hold_char);[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);[m
[31m-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);[m
[31m-		}[m
[31m-[m
[31m-	/* Only push if top exists. Otherwise, replace top. */[m
[31m-	if (YY_CURRENT_BUFFER)[m
[31m-		(yy_buffer_stack_top)++;[m
[31m-	YY_CURRENT_BUFFER_LVALUE = new_buffer;[m
[31m-[m
[31m-	/* copied from yy_switch_to_buffer. */[m
[31m-	yy_load_buffer_state(  );[m
[31m-	(yy_did_buffer_switch_on_eof) = 1;[m
[31m-}[m
[31m-[m
[31m-/** Removes and deletes the top of the stack, if present.[m
[31m- *  The next element becomes the new top.[m
[31m- *  [m
[31m- */[m
[31m-void yypop_buffer_state (void)[m
[31m-{[m
[31m-    	if (!YY_CURRENT_BUFFER)[m
[31m-		return;[m
[31m-[m
[31m-	yy_delete_buffer(YY_CURRENT_BUFFER );[m
[31m-	YY_CURRENT_BUFFER_LVALUE = NULL;[m
[31m-	if ((yy_buffer_stack_top) > 0)[m
[31m-		--(yy_buffer_stack_top);[m
[31m-[m
[31m-	if (YY_CURRENT_BUFFER) {[m
[31m-		yy_load_buffer_state(  );[m
[31m-		(yy_did_buffer_switch_on_eof) = 1;[m
[31m-	}[m
[31m-}[m
[31m-[m
[31m-/* Allocates the stack if it does not exist.[m
[31m- *  Guarantees space for at least one push.[m
[31m- */[m
[31m-static void yyensure_buffer_stack (void)[m
[31m-{[m
[31m-	yy_size_t num_to_alloc;[m
[31m-    [m
[31m-	if (!(yy_buffer_stack)) {[m
[31m-[m
[31m-		/* First allocation is just for 2 elements, since we don't know if this[m
[31m-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an[m
[31m-		 * immediate realloc on the next call.[m
[31m-         */[m
[31m-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */[m
[31m-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc[m
[31m-								(num_to_alloc * sizeof(struct yy_buffer_state*)[m
[31m-								);[m
[31m-		if ( ! (yy_buffer_stack) )[m
[31m-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );[m
[31m-[m
[31m-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));[m
[31m-[m
[31m-		(yy_buffer_stack_max) = num_to_alloc;[m
[31m-		(yy_buffer_stack_top) = 0;[m
[31m-		return;[m
[31m-	}[m
[31m-[m
[31m-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){[m
[31m-[m
[31m-		/* Increase the buffer to prepare for a possible push. */[m
[31m-		yy_size_t grow_size = 8 /* arbitrary grow size */;[m
[31m-[m
[31m-		num_to_alloc = (yy_buffer_stack_max) + grow_size;[m
[31m-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc[m
[31m-								((yy_buffer_stack),[m
[31m-								num_to_alloc * sizeof(struct yy_buffer_state*)[m
[31m-								);[m
[31m-		if ( ! (yy_buffer_stack) )[m
[31m-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );[m
[31m-[m
[31m-		/* zero only the new slots.*/[m
[31m-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));[m
[31m-		(yy_buffer_stack_max) = num_to_alloc;[m
[31m-	}[m
[31m-}[m
[31m-[m
[31m-/** Setup the input buffer state to scan directly from a user-specified character buffer.[m
[31m- * @param base the character buffer[m
[31m- * @param size the size in bytes of the character buffer[m
[31m- * [m
[31m- * @return the newly allocated buffer state object.[m
[31m- */[m
[31m-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )[m
[31m-{[m
[31m-	YY_BUFFER_STATE b;[m
[31m-    [m
[31m-	if ( size < 2 ||[m
[31m-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||[m
[31m-	     base[size-1] != YY_END_OF_BUFFER_CHAR )[m
[31m-		/* They forgot to leave room for the EOB's. */[m
[31m-		return NULL;[m
[31m-[m
[31m-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );[m
[31m-	if ( ! b )[m
[31m-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );[m
[31m-[m
[31m-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */[m
[31m-	b->yy_buf_pos = b->yy_ch_buf = base;[m
[31m-	b->yy_is_our_buffer = 0;[m
[31m-	b->yy_input_file = NULL;[m
[31m-	b->yy_n_chars = b->yy_buf_size;[m
[31m-	b->yy_is_interactive = 0;[m
[31m-	b->yy_at_bol = 1;[m
[31m-	b->yy_fill_buffer = 0;[m
[31m-	b->yy_buffer_status = YY_BUFFER_NEW;[m
[31m-[m
[31m-	yy_switch_to_buffer( b  );[m
[31m-[m
[31m-	return b;[m
[31m-}[m
[31m-[m
[31m-/** Setup the input buffer state to scan a string. The next call to yylex() will[m
[31m- * scan from a @e copy of @a str.[m
[31m- * @param yystr a NUL-terminated string to scan[m
[31m- * [m
[31m- * @return the newly allocated buffer state object.[m
[31m- * @note If you want to scan bytes that may contain NUL values, then use[m
[31m- *       yy_scan_bytes() instead.[m
[31m- */[m
[31m-YY_BUFFER_STATE yy_scan_string (const char * yystr )[m
[31m-{[m
[31m-    [m
[31m-	return yy_scan_bytes( yystr, (int) strlen(yystr) );[m
[31m-}[m
[31m-[m
[31m-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will[m
[31m- * scan from a @e copy of @a bytes.[m
[31m- * @param yybytes the byte buffer to scan[m
[31m- * @param _yybytes_len the number of bytes in the buffer pointed to by @a byt